// Code generated by sqlc. DO NOT EDIT.
// source: ledger.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const addUserToLedger = `-- name: AddUserToLedger :exec
UPDATE ledgers SET members = ARRAY_APPEND(members, $2)
WHERE id = $1
`

type AddUserToLedgerParams struct {
	ID          uuid.UUID
	User          uuid.UUID
}

func (q *Queries) AddUserToLedger(ctx context.Context, arg AddUserToLedgerParams) error {
	_, err := q.db.ExecContext(ctx, addUserToLedger, arg.ID, arg.User)
	return err
}

const createLedger = `-- name: CreateLedger :one
INSERT INTO ledgers (
    title, members
)
VALUES (
    $1, $2
)
ON CONFLICT DO NOTHING
RETURNING id, title, members, created_at, updated_at
`

type CreateLedgerParams struct {
	Title   string
	Members []uuid.UUID
}

func (q *Queries) CreateLedger(ctx context.Context, arg CreateLedgerParams) (Ledger, error) {
	row := q.db.QueryRowContext(ctx, createLedger, arg.Title, pq.Array(arg.Members))
	var i Ledger
	err := row.Scan(
		&i.ID,
		&i.Title,
		pq.Array(&i.Members),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLedger = `-- name: DeleteLedger :exec
DELETE FROM ledgers
WHERE id = $1
`

func (q *Queries) DeleteLedger(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteLedger, id)
	return err
}

const getLedgerById = `-- name: GetLedgerById :one
SELECT ledger
FROM (
  SELECT l.id, l.title, json_agg(json_build_object(t.*)) AS transactions
  FROM ledgers l
    JOIN transactions t ON l.id = t.ledger
  WHERE l.id = $1
  GROUP BY l.id
) ledger
`

func (q *Queries) GetLedgerById(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, getLedgerById, id)
	var ledger uuid.UUID
	err := row.Scan(&ledger)
	return ledger, err
}

const getTransactions = `-- name: GetTransactions :many
SELECT id, ledger, debitor, creditor, date, amount, note, created_at, updated_at FROM transactions
WHERE transactions.ledger = $1
`

func (q *Queries) GetTransactions(ctx context.Context, ledger uuid.UUID) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getTransactions, ledger)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Ledger,
			&i.Debitor,
			&i.Creditor,
			&i.Date,
			&i.Amount,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeUserFromLedger = `-- name: RemoveUserFromLedger :exec
UPDATE ledgers SET members = ARRAY_REMOVE(members, $2)
WHERE ledgers.id::text = $1
`

type RemoveUserFromLedgerParams struct {
	ID          uuid.UUID
	User          uuid.UUID
}

func (q *Queries) RemoveUserFromLedger(ctx context.Context, arg RemoveUserFromLedgerParams) error {
	_, err := q.db.ExecContext(ctx, removeUserFromLedger, arg.ID, arg.User)
	return err
}
